{"version":3,"file":"3cae7de6ce910c010025.worker.js","sources":["webpack:///webpack/bootstrap 3cae7de6ce910c010025","webpack:///../~/promise-worker-transferable/register.js","webpack:///../~/wav-decoder/index.js","webpack:///../~/is-promise/index.js","webpack:///../~/webpack/buildin/global.js","webpack:///./workers/readWav.worker.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3cae7de6ce910c010025","'use strict';\r\n\r\nvar isPromise = require('is-promise');\r\n\r\nfunction registerPromiseWorker(callback) {\r\n\r\n  function postOutgoingMessage(e, messageId, error, result) {\r\n    function postMessage(msg, transferList) {\r\n      /* istanbul ignore if */\r\n      if (typeof self.postMessage !== 'function') { // service worker\r\n        e.ports[0].postMessage(msg, transferList);\r\n      } else { // web worker\r\n        self.postMessage(msg, transferList);\r\n      }\r\n    }\r\n    if (error) {\r\n      /* istanbul ignore else */\r\n      if (typeof console !== 'undefined' && 'error' in console) {\r\n        // This is to make errors easier to debug. I think it's important\r\n        // enough to just leave here without giving the user an option\r\n        // to silence it.\r\n        console.error('Worker caught an error:', error);\r\n      }\r\n      postMessage([messageId, {\r\n        message: error.message\r\n      }]);\r\n    } else {\r\n      if (result instanceof MessageWithTransferList) {\r\n        postMessage([messageId, null, result.message], result.transferList);\r\n      } else {\r\n        postMessage([messageId, null, result]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function tryCatchFunc(callback, message) {\r\n    try {\r\n      return {res: callback(message, withTransferList)};\r\n    } catch (e) {\r\n      return {err: e};\r\n    }\r\n  }\r\n\r\n  function withTransferList(resMessage, transferList) {\r\n    return new MessageWithTransferList(resMessage, transferList);\r\n  } \r\n\r\n  function handleIncomingMessage(e, callback, messageId, message) {\r\n\r\n    var result = tryCatchFunc(callback, message);\r\n\r\n    if (result.err) {\r\n      postOutgoingMessage(e, messageId, result.err);\r\n    } else if (!isPromise(result.res)) {\r\n        postOutgoingMessage(e, messageId, null, result.res);\r\n    } else {\r\n      result.res.then(function (finalResult) {\r\n        postOutgoingMessage(e, messageId, null, finalResult);\r\n      }, function (finalError) {\r\n        postOutgoingMessage(e, messageId, finalError);\r\n      });\r\n    }\r\n  }\r\n\r\n  function onIncomingMessage(e) {\r\n    var payload = e.data;\r\n    if (!Array.isArray(payload) || payload.length !== 2) {\r\n      // message doens't match communication format; ignore\r\n      return;\r\n    }\r\n    var messageId = payload[0];\r\n    var message = payload[1];\r\n\r\n    if (typeof callback !== 'function') {\r\n      postOutgoingMessage(e, messageId, new Error(\r\n        'Please pass a function into register().'));\r\n    } else {\r\n      handleIncomingMessage(e, callback, messageId, message);\r\n    }\r\n  }\r\n\r\n  function MessageWithTransferList(message, transferList) {\r\n    this.message = message;\r\n    this.transferList = transferList;\r\n  }\r\n\r\n  self.addEventListener('message', onIncomingMessage);\r\n}\r\n\r\nmodule.exports = registerPromiseWorker;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/promise-worker-transferable/register.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n\nvar formats = {\n  0x0001: \"lpcm\",\n  0x0003: \"lpcm\"\n};\n\nfunction decode(buffer) {\n  if (global.Buffer && buffer instanceof global.Buffer) {\n    buffer = Uint8Array.from(buffer).buffer;\n  }\n\n  return new Promise(function(resolve, reject) {\n    var dataView = new DataView(buffer);\n    var reader = createReader(dataView);\n\n    if (reader.string(4) !== \"RIFF\") {\n      return reject(new TypeError(\"Invalid WAV file\"));\n    }\n\n    reader.uint32(); // skip file length\n\n    if (reader.string(4) !== \"WAVE\") {\n      return reject(new TypeError(\"Invalid WAV file\"));\n    }\n\n    var format = null;\n    var audioData = null;\n\n    do {\n      var chunkType = reader.string(4);\n      var chunkSize = reader.uint32();\n\n      switch (chunkType) {\n      case \"fmt \":\n        format = decodeFormat(reader, chunkSize);\n        if (format instanceof Error) {\n          return reject(format);\n        }\n        break;\n      case \"data\":\n        audioData = decodeData(reader, chunkSize, format);\n        if (audioData instanceof Error) {\n          return reject(format);\n        }\n        break;\n      default:\n        reader.skip(chunkSize);\n        break;\n      }\n    } while (audioData === null);\n\n    resolve(audioData);\n  });\n}\n\nfunction decodeFormat(reader, chunkSize) {\n  var formatId = reader.uint16();\n\n  if (!formats.hasOwnProperty(formatId)) {\n    return new TypeError(\"Unsupported format in WAV file: 0x\" + formatId.toString(16));\n  }\n\n  var format = {\n    formatId: formatId,\n    floatingPoint: formatId === 0x0003,\n    numberOfChannels: reader.uint16(),\n    sampleRate: reader.uint32(),\n    byteRate: reader.uint32(),\n    blockSize: reader.uint16(),\n    bitDepth: reader.uint16()\n  };\n  reader.skip(chunkSize - 16);\n\n  return format;\n}\n\nfunction decodeData(reader, chunkSize, format) {\n  var length = Math.floor(chunkSize / format.blockSize);\n  var numberOfChannels = format.numberOfChannels;\n  var sampleRate = format.sampleRate;\n  var channelData = new Array(numberOfChannels);\n\n  for (var ch = 0; ch < numberOfChannels; ch++) {\n    channelData[ch] = new Float32Array(length);\n  }\n\n  var retVal = readPCM(reader, channelData, length, format);\n\n  if (retVal instanceof Error) {\n    return retVal;\n  }\n\n  return {\n    numberOfChannels: numberOfChannels,\n    length: length,\n    sampleRate: sampleRate,\n    channelData: channelData\n  };\n}\n\nfunction readPCM(reader, channelData, length, format) {\n  var bitDepth = format.bitDepth;\n  var floatingPoint = format.floatingPoint ? \"f\" : \"\";\n  var methodName = \"pcm\" + bitDepth + floatingPoint;\n\n  if (!reader[methodName]) {\n    return new TypeError(\"Not supported bit depth: \" + format.bitDepth);\n  }\n\n  var read = reader[methodName].bind(reader);\n  var numberOfChannels = format.numberOfChannels;\n\n  for (var i = 0; i < length; i++) {\n    for (var ch = 0; ch < numberOfChannels; ch++) {\n      channelData[ch][i] = read();\n    }\n  }\n\n  return null;\n}\n\nfunction createReader(dataView) {\n  var pos = 0;\n\n  return {\n    skip: function(n) {\n      pos += n;\n    },\n    uint8: function() {\n      var data = dataView.getUint8(pos, true);\n\n      pos += 1;\n\n      return data;\n    },\n    int16: function() {\n      var data = dataView.getInt16(pos, true);\n\n      pos += 2;\n\n      return data;\n    },\n    uint16: function() {\n      var data = dataView.getUint16(pos, true);\n\n      pos += 2;\n\n      return data;\n    },\n    uint32: function() {\n      var data = dataView.getUint32(pos, true);\n\n      pos += 4;\n\n      return data;\n    },\n    string: function(n) {\n      var data = \"\";\n\n      for (var i = 0; i < n; i++) {\n        data += String.fromCharCode(this.uint8());\n      }\n\n      return data;\n    },\n    pcm8: function() {\n      var data = dataView.getUint8(pos) - 128;\n\n      pos += 1;\n\n      return data < 0 ? data / 128 : data / 127;\n    },\n    pcm16: function() {\n      var data = dataView.getInt16(pos, true);\n\n      pos += 2;\n\n      return data < 0 ? data / 32768 : data / 32767;\n    },\n    pcm24: function() {\n      var x0 = dataView.getUint8(pos + 0);\n      var x1 = dataView.getUint8(pos + 1);\n      var x2 = dataView.getUint8(pos + 2);\n      var xx = (x0 + (x1 << 8) + (x2 << 16));\n      var data = xx > 0x800000 ? xx - 0x1000000 : xx;\n\n      pos += 3;\n\n      return data < 0 ? data / 8388608 : data / 8388607;\n    },\n    pcm32: function() {\n      var data = dataView.getInt32(pos, true);\n\n      pos += 4;\n\n      return data < 0 ? data / 2147483648 : data / 2147483647;\n    },\n    pcm32f: function() {\n      var data = dataView.getFloat32(pos, true);\n\n      pos += 4;\n\n      return data;\n    },\n    pcm64f: function() {\n      var data = dataView.getFloat64(pos, true);\n\n      pos += 8;\n\n      return data;\n    }\n  };\n}\n\nmodule.exports.decode = decode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/wav-decoder/index.js\n// module id = 1\n// module chunks = 0","module.exports = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/is-promise/index.js\n// module id = 2\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/webpack/buildin/global.js\n// module id = 3\n// module chunks = 0","/* eslint-disable */\n\nimport registerPromiseWorker from \"promise-worker-transferable/register\";\nimport { decode } from \"wav-decoder\";\n\nregisterPromiseWorker((file) => {\n  return new Promise((resolve) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      resolve(reader.result);\n    };\n    reader.readAsArrayBuffer(file);\n  }).then(buffer => decode(buffer));\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./workers/readWav.worker.js\n// module id = 4\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvNA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}